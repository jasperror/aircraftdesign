classdef subsystems
    properties (Constant)
        V_taxi_carrier = 5; % Maximum carrier taxi speed, m/s
        V_taxi_airfield = 15; % Maximum airfield taxi speed, m/s
        ddtheta = 15; % Takeoff pitch angular acceleration, deg/s^2
    end
    properties (Constant, Hidden, Access=private)
        C_HT = 0.4; % Horizontal tail volume coefficient (fighter)
        C_VT = 0.09; % Vertical tail volume coefficient (fighter)
        C_C = 0.1; % Canard volume coefficient

        A_c = 1.75; % Canard aspect ratio (Eurofighter Typhoon), []
        A_vt = 1.2; % Vertical tail aspect ratio (F18), []

        E_al = 67e9; % Elastic modulus of 7076 Aluminum, Pa
        E_st = 205e9; % Elastic modulus of 4340 Steel, normalized, Pa
        I = 0; % Average 2nd Moment of area of cross-section
        y_max = 0.05; % Maximum vertical deflection of fuselage under load, m
        I_yy_mg = 3; % Average moment of inertia in yy-plane about cg

        F_nW = 0.2; % Assuming F_n = 0.2*W0

        BPR = 0.6; % Engine bypass ratio, based on F135
    end
    properties % Inputs
        m % maximum takeoff weight, kg
        m_f % Fuel weight, kg
        m_c = 250; % Crew weight, kg
        MAC % Wing mean aerodynamic chord, m
        b % Wingspan, m
        S_ref % Wing reference area, m^2
        n_vtail = 1; % Number of vertical tails
        D_to % Takeoff drag, N
        T0 % Takeoff thrust, N
        M_ac % Pitching moment about aerodynamic center, Nm
        a_to % Takeoff acceleration at rotation, m/s^2 a = V_end^2/200
        L_to % Takeoff lift
        xbar_ac % Location of aerodynamic center, m
        xbar_ac_can = 0.25; % Location of normalized aerodynamic center of canard, []
        L_canard % Canard lift at takeoff, N
        alpha_to % Takeoff angle of attack, deg
        alpha_incidence = 0; % Angle of incidence, deg
        c_root % Wing root chord, m
        Lambda_05c % Sweep of half-chord, deg
        Lambda_LE % Leading edge sweep, deg
        lambda % Taper ratio, []
        S_wet_fus % Fuselage wetted surface area, m^2
        W0mm % 0->Mid-mission weight fraction, []
        S_exposed % Wing exposed surface area, m^2
    end
    properties(Dependent) % General Properties
        L_fus % Fuselage length, m
        d % Fuselage hydraulic diameter, m
        AB % Distance to rear fuselage upsweep from main gear, m
    end
    properties (Dependent) % Control & Engine Properties
        S_ref_C % Canard reference area, m^2
        S_ref_VT % Vertical tail reference area, m^2
        aileron % Aileron parameters
        rudder % Rudder parameters
        verticaltail % Vertical Tail Parameters
        canard % Canard Parameters, assuming 100% elevator
        L_C % Arm to aerodynamic center of canard from aerodynamic center of wing
        L_VT % Arm from AC of VT to AC of wing
        engine % Engine data structure
    end
    properties (Dependent) % Gear & CG Properties DATUM: LEADING EDGE OF ROOT OF REFERENCE WING
        B % Wheelbase, m
        T % Track, m
        h_g % Main gear height, m
        r_carrier % Minimum corner radius at carrier taxi speed, m
        r_airfield % Minimum corner radius at airfield taxi speed, m
        z_cg % CG height, m
        B_n % Nose gear wheelbase, m
        B_n_max % Maximum B_n, m
        x_mg % Location of main gear, m
        x_cg % Location of cg, m
        x_cg_fore % Most forward cg location, m
        x_cg_aft % Most aft cg location, m
    end
    properties (Dependent,Hidden,Access=private)
        x_mac % Location of leading edge of MAC of wing, m
        cgdata % Structure of various CG-related data
    end
    methods % General
        function L_fus = get.L_fus(obj)
            L_fus = 0.389*obj.m^0.39; % M4p.3
        end
        function d = get.d(obj)
            d = obj.L_fus/10; % M4p.3 Comprimising drag reduction (compare with competitors?)
        end
        function AB = get.AB(obj)
            AB = 0.25*obj.L_fus; % Average distance fraction between F18E and Typhoon
        end
    end
    methods % Controls
        function S_ref_C = get.S_ref_C(obj)
            S_ref_C = obj.C_C*obj.MAC*obj.S_ref/obj.L_C;
        end
        function S_ref_VT = get.S_ref_VT(obj)
            S_ref_VT = obj.n_vtail*obj.C_VT*obj.S_ref*obj.b/obj.L_VT;
        end
        function y = get.aileron(obj)
            y.chord = 0.22*obj.b;
            y.span = 0.4*obj.b;
        end
        function y = get.rudder(obj)
            y.chord = 0.35*obj.verticaltail.chord;
            y.span = 0.5*obj.verticaltail.span;
        end
        function y = get.verticaltail(obj)
            y.A = obj.A_vt;
            y.span = sqrt(obj.S_ref_VT*y.A);
            y.chord = obj.S_ref_VT/y.span;
        end
        function y = get.canard(obj)
            y.A = obj.A_c;
            y.span = sqrt(obj.S_ref_C*y.A);
            y.chord = obj.S_ref_VT/y.span;
        end
        function y = get.L_C(obj)
            y = 0.4*obj.L_fus; % From competitors
        end
        function y = get.L_VT(obj)
            y = 0.2*obj.L_fus; % From competitors
        end
    end
    methods % Gear & CG
        function B = get.B(obj)
            B = 0.325*obj.L_fus; % estimation
        end
        function T = get.T(obj)
            T_a = 2*tand(26)*obj.z_cg; % Static overturn
            T_b = 2*obj.B*tan(asin(obj.z_cg/obj.B_n_max*tand(28))); % Angled static overturn
            T_min = max([T_a,T_b]);
            T_max = (48*obj.E_al*obj.I*obj.B*obj.y_max/(obj.m*obj.B_n_max))^(1/3); % From structural deflection
            if T_max < T_min
                T_max = (48*obj.E_st*obj.I*obj.B*obj.y_max/(obj.m*obj.B_n_max))^(1/3);
            end
            if T_max <= T_min
                T = T_min; % Ignore the problem
            else % Extreme guess-work
                if T_max > 1.5*T_min % Should also be less than wingspan
                    T = mean([T_min, T_max]); % If close, average it
                else
                    T = 1.3*T_min; % Idk man
                end
            end
        end
        function h = get.h_g(obj)
            h_fus = 1; % Height of gear for fuselage/payload clearance, assumption
            h_c = 0.4; % Clearance during rotation, assumption (Raymer)
            h_rearfus = obj.AB*tand(obj.alpha_to)+h_c/cosd(obj.alpha_to); % Height of gear for rear fuselage clearance during rotation
            h = max([h_fus, h_rearfus]);
        end
        function r = get.r_carrier(obj)
            r = 2*obj.V_taxi_carrier^2*obj.z_cg/(obj.T*const.g);
        end
        function r = get.r_airfield(obj)
            r = 2*obj.V_taxi_airfield^2*obj.z_cg/(obj.T*const.g);
        end
        function 
        function B_n = get.B_n(obj)
            B_n = obj.B*(1-obj.F_nW);
        end
        function B_n_max = get.B_n_max(obj)
            B_n_max = (1-obj.F_nW)*obj.B + obj.a_to*obj.z_cg/const.g;
        end
        function x_mg = get.x_mg(obj)
            % Takeoff rotation rate
            % Assuming thrust, drag centered at center of fuselage
            % Assuming no lift or corresponding pitching moment from fuselage
            x_ac = obj.x_mac + obj.xbar_ac*obj.MAC;
            x_can = obj.L_C - x_ac;
            a1 = obj.I_yy_mg*deg2rad(obj.ddtheta);
            a2 = -obj.D_to*(obj.h_g+obj.d/2);
            a3 = obj.T0*obj.z_cg; % Assuming engines mounted at CG for better maneuverability
            a4 = -obj.M_ac;
            a5 = -obj.m*obj.a_to*obj.z_cg;
            a6 = -obj.m*const.g*obj.x_cg;
            a7 = obj.L_to*x_ac;
            a8 = obj.L_canard*x_can;
            num = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;
            den = obj.L_to + obj.L_canard - obj.m*const.g;
            x_mg_theta = num/den;
            x_mg_tb = obj.z_cg*tand(obj.alpha_to+obj.alpha_incidence+5);
            x_mg = max([x_mg_theta, x_mg_tb]);
        end
        function x_cg = get.x_cg(obj)
            x_cg = sum( obj.cgdata(:,1).*obj.cgdata(:,3) )/sum(obj.cgdata(:,3));
        end
        function z_cg = get.z_cg(obj)
            z_cg = sum( obj.cgdata(:,2).*obj.cgdata(:,3) )/sum(obj.cgdata(:,3));
        end
        function data = get.cgdata(obj)
            h_fus = obj.h_g + 0.5*obj.d; % Fuselage centerline height, m
            data = [
                -(obj.b/8*tand(obj.Lambda_05c) + obj.c_root/2), h_fus, 2*454.5; % Payload station 1 (1/4b)
                -(obj.b/4*tand(obj.Lambda_05c) + obj.c_root/2), h_fus, 2*454.5; % Payload station 2 (1/2b)
                -(3*obj.b/8*tand(obj.Lambda_05c) + obj.c_root/2), h_fus, 2*454.5; % Payload station 3 (3/4b)
                -(obj.b/2*tand(obj.Lambda_05c) + obj.c_root/2), h_fus, 2*158.2; % Payload station 4 (wingtip)
                -obj.x_mac - obj.c_root/2, h_fus, obj.m_f;
                -0.6*obj.MAC, h_fus, 44*obj.S_exposed;
                obj.L_C + obj.x_mac - obj.xbar_ac*obj.MAC, h_fus, 20*obj.S_ref_C;
                -obj.L_VT - obj.x_mac - obj.xbar_ac*obj.MAC - 0.15*obj.verticaltail.chord, h_fus + 0.5*obj.d + 0.4*obj.verticaltail.span, 26*obj.S_ref_VT;
                -0.2586*obj.c_root + 0.02866*obj.L_fus, h_fus, 23*obj.S_wet_fus*1.25;
                obj.B_n, 0.35*obj.h_g, 0.15*0.033*obj.m*1.25 + 0.003*obj.m*obj.W0mm;
                obj.B_n-obj.B, 0.35*obj.h_g, 0.033*obj.m*1.25;
                -0.3646*obj.c_root - 0.1889*obj.L_fus, h_fus, 1.3*obj.engine.W;
                -0.2973*obj.c_root + 0.3446*obj.L_fus, h_fus, 20+obj.m_c;
                -0.4*obj.L_fus, obj.h_g, 0.008*obj.m*obj.W0mm
            ];
        end
        function xcg = get.x_cg_fore(obj)
            xcg_g = obj.x_cg;
            err = 0.002;
            while err > 0.001

                W_aft = obj.cgdata(obj.cgdata(:,1)<xcg_g,3);
                num = sum(obj.cgdata(:,1).*obj.cgdata(:,3)) - sum( W_aft.*obj.cgdata(obj.cgdata(:,1)<xcg_g, 1) );
                xcg = num/( sum(obj.cgdata(:,3))-sum(W_aft) );
                err = (xcg_g-xcg)/xcg;
                xcg_g = xcg;
            end
        end
        function xcg = get.x_cg_aft(obj)
            xcg_g = obj.x_cg;
            err = 0.002;
            while err > 0.001
                W_fore = obj.cgdata(obj.cgdata(:,1)>xcg_g,3);
                num = sum(obj.cgdata(:,1).*obj.cgdata(:,3)) - sum( W_fore.*obj.cgdata(obj.cgdata(:,1)>xcg_g, 1) );
                xcg = num/( sum(obj.cgdata(:,3))-sum(W_fore) );
                err = (xcg_g-xcg)/xcg;
                xcg_g=xcg;
            end
        end
        function x_mac = get.x_mac(obj)
            Y = obj.b/6*(1+2*obj.lambda)/(1+obj.lambda);
            x_mac = Y*tand(obj.Lambda_LE);
        end
        function eng = get.engine(obj)
            eng.W = 14.7*(obj.T0/1e3)^1.1*exp(-0.045*obj.BPR);
        end
        function cgtable(obj)
            table(obj.cgdata(:,1),obj.cgdata(:,2),obj.cgdata(:,3),'VariableNames',{'x_cg, m','z_cg, m','m, kg'})
        end
    end
end
